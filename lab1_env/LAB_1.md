# LAB 1
- By the end of Lab 1, you will:
- Crash PostgreSQL on purpose
- Observe WAL recovery
- Understand why data survives
- Be able to explain WAL in plain English
## Step 1: Create real data
1. Create script ```create_wal_test.sql```
    ```
    CREATE TABLE wal_test (
        id SERIAL PRIMARY KEY,
        message TEXT
    );

    INSERT INTO wal_test (message)
    SELECT 'message ' || generate_series(1, 10000);

    ```
2. Run
    ```
    psql -h localhost -p 5433 -U postgres -d labdb -f /Users/anthonytran/Desktop/postgresSQL-labatory/lab1_env/create_wal_test.sql
    ```
3. Verify  
    ```
    psql -h localhost -p 5433 -U postgres -d labdb
    ```
    ```
    SELECT count(*) FROM wal_test;
    ```
    üëâ You should see 10000.
## Step 2: Identify the Postgres process (important)
In another terminal
```
docker exec -it pg_node1 ps aux | grep postgres
```
## Step 3: Step 3: CRASH PostgreSQL (not stop)
‚ö†Ô∏è This is intentional.
```
docker kill -s SIGKILL pg_node1
```
This simulates:
- power loss
- kernel panic
- VM crash
## Step 4: Restart the container
```
docker start pg_node1
```
Wait ~10 seconds.
## Step 5: Observe recovery
Check logs:
```
docker logs pg_node1
```
Look for phrases like:
- ``redo starts at``
- ``redo done``
- ``database system is ready``
## Step 6: Verify data integrity
Reconnect:
```
psql -h localhost -p 5433 -U postgres -d labdb
```
Run:
```
SELECT count(*) FROM wal_test;
```
üëâ Expected result: 10000
## üß† Reflection questions (answer these next)
Don‚Äôt Google ‚Äî think.  
1. Why did data survive even though we killed Postgres?  
    - Data survived because PostgreSQL had already flushed the WAL records for committed transactions to disk. During restart, PostgreSQL replayed those WAL records to reconstruct data pages, even though PostgreSQL was killed abruptly. 

2. What role did WAL play before data hit disk?
- What WAL actually does:
    - Records what changed at the storage level
    - Not the SQL
    - Not the plan
    - Not the execution steps
- WAL records the final effects of changes in an ordered, durable log before data pages are written to disk, ensuring that committed changes can always be replayed.

3. Why is this crucial for replication?
- Replication relies on WAL because replicas do not execute SQL themselves; they replay the same WAL stream generated by the primary, which guarantees identical data changes and consistency.